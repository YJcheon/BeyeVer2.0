#include <string>
#include <iostream>
#include <raspicam/raspicam_cv.h>
#include <opencv2/opencv.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/video/video.hpp>
#include <opencv2/core/core.hpp>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#define resizeSize 2


// opencv code
using namespace cv;
using namespace std;
int movcount = 0;
int noisehandle = 0;// to handle kind of noise
int errorhandle = 0;
int stairhandle = 0;
int downhandle = 0;
Mat savemov;
int test_flag =0;
int obf =0;
int upf =0;
int dof =0;
int crs =0;
bool saveset = false; // to handle conflict
bool downbit = false;
bool stairbit = false;
int stairbitcheck = 0;
int downstairbit = 0;

class WatershedSegmenter {
private:
	cv::Mat markers;
public:
	void setMarkers(cv::Mat& markerImage)
	{
		markerImage.convertTo(markers, CV_32S);
	}

	cv::Mat process(cv::Mat &image)
	{
		cv::watershed(image, markers);
		markers.convertTo(markers, CV_8U);
		return markers;
	}
};

int main() {

	//global variables
	Mat origin;		// 원본
	Mat resizeImage;	// 사이즈 조정
	Mat MOG2Image; //fg mask fg mask generated by MOG2 method
	Mat grayImage;
	Mat contrastImage;
	Mat blurImage;
	Mat mophologyImage;
	Mat thresholdImage;
	Mat ContourImg;

	Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

	
	pMOG2 = createBackgroundSubtractorMOG2(500, 16, true);

	char fileName[100] = "output4.mp4";
	VideoCapture stream1(fileName);
	Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3, 3));
	Mat element2 = getStructuringElement(MORPH_ELLIPSE, Size(3, 3));
	Mat element3 = getStructuringElement(MORPH_RECT, Size(1, 1));

	//unconditional loop   
	while (true) {
		//if (!(stream1.read(origin))) //get one frame form video   
		//break;
		// 이미지 size 조절
		Camera.grab();
		Camera.retrieve(origin);
		Mat origin = stream1
		resize(origin, resizeImage, Size(origin.size().width / resizeSize, origin.size().height / resizeSize));
	 
		/////////////////////////////////////////////////////////////////
		//1단계 : 밝기 대조 조정
		contrastImage = resizeImage.clone();

		Mat sharpening;
		GaussianBlur(contrastImage, sharpening, Size(0, 0), 3);
		cv::addWeighted(contrastImage, 1.5, sharpening, -0.5, 0, sharpening);
		imshow("1. sharpening", sharpening);
		Mat gray;
		cvtColor(sharpening, gray, CV_RGB2GRAY);
		//imshow("2. grayscale", gray);
		Mat binary;
		Mat binaryroad;
		threshold(gray, binary, 55, 255, THRESH_BINARY);
		threshold(gray, binaryroad, 127, 255, THRESH_BINARY);
		dilate(binaryroad, binaryroad, Mat(), Point(1, 1), 1);

		//imshow("binset", binaryroad);
		for (int y = 0; y < contrastImage.rows; y++) {
			for (int x = 0; x < contrastImage.cols; x++) {
				binary.at<uchar>(y, x) = 255 - binary.at<uchar>(y, x);
			}
		}
		Mat edge;
		Mat bincheck;
		bincheck = gray.clone();
		threshold(bincheck, bincheck, 110, 255, THRESH_BINARY);
		Canny(bincheck, bincheck, 130, 210, 3);
		threshold(bincheck, bincheck, 0, 255, CV_THRESH_BINARY_INV);
		erode(bincheck, bincheck, Mat(), Point(1, 1), 1);
		imshow("test edge", bincheck);
		int downx = 0;
		int downindex = 0;
		int downy = 0;
		int downsomethingy = contrastImage.rows;
		bool countforfirst = false;
		bool countformax = false;

		//필요없는내용
		for (int x = (contrastImage.cols / 5 * 2); x < (contrastImage.cols / 5 * 4); x++) {
			for (int y = (contrastImage.rows / 5 * 3); y < contrastImage.rows; y++) {
				if (bincheck.at<uchar>(y, x) == 0)
				{
					if (y < downsomethingy) {
						downsomethingy = y;
						countforfirst = true;
					}
				}
			}
			if (countforfirst) {
				if (abs(downsomethingy - downy) < 4) {
					countformax = true;
				}
				downy = downsomethingy;
			}
			if (countformax) {
				downindex++;
			}
			downsomethingy = contrastImage.rows;
			countformax = false;
			countforfirst = false;
		}
		Canny(gray, edge, 130, 210, 3); // Canny 연산
		threshold(edge, edge, 0, 255, CV_THRESH_BINARY_INV); // sobel 영상과 비교하려고 반전
															 //imshow("Canny Image", edge);

															 /////////////////////////////////////////////////////////////////
															 //2단계 : 블러 처리 -> 인식되는 범위를 늘려줌
		blur(sharpening, blurImage, Size(3, 3));
		//medianBlur(resizeF, resizeF, 5);
		//GaussianBlur(resizeF, resizeF, Size(5, 5), 1.5);


		/////////////////////////////////////////////////////////////////
		//3단계 : MOG2 적용 -> 배경 제거
		//pMOG2->apply(blurImage, MOG2Image);
		//imshow("2. blur + MOG2", MOG2Image);
		//계단 계산을 위한 전처리
		Mat closing;
		morphologyEx(blurImage, closing, MORPH_CLOSE, element);
		Mat forstair;
		cvtColor(closing, forstair, CV_RGB2GRAY);
		threshold(forstair, forstair, 230, 255, THRESH_BINARY);
		erode(forstair, forstair, Mat(), Point(1, 1), 5);
		imshow("되라", forstair);
		//imshow("4. closing", closing);
		//장애물 계산을 위한 전처리
		Mat labeling;
		Mat magic = edge.clone();
		int height = magic.size().height;
		int width = magic.size().width;
		erode(edge, labeling, Mat(), Point(1, 1), 1);
		for (int y = 0; y < contrastImage.rows; y++) {
			for (int x = 0; x < contrastImage.cols; x++) {
				if ((binary.at<uchar>(y, x) - labeling.at<uchar>(y, x)) >(150)) {
					magic.at<uchar>(y, x) = (binary.at<uchar>(y, x) - labeling.at<uchar>(y, x));
				}
				else
					magic.at<uchar>(y, x) = 0;
			}
		}
		Mat magic4;
		Mat magic2 = edge.clone();
		//erode(magic, magic, Mat(), Point(1, 1), 1);
		//dilate(magic, magic, Mat(), Point(1, 1), 1);
		for (int y = 0; y < contrastImage.rows; y++) {
			for (int x = 0; x < contrastImage.cols; x++) {
				if ((magic.at<uchar>(y, x) - labeling.at<uchar>(y, x)) >(200)) {
					magic2.at<uchar>(y, x) = (magic.at<uchar>(y, x) - labeling.at<uchar>(y, x));
				}
				else
					magic2.at<uchar>(y, x) = 0;
			}
		}
		dilate(magic2, magic2, Mat(), Point(1, 1), 1);
		imshow("blob", magic2);
		int xmar = 0;
		int marindex = 0;
		int xmax = 0;
		for (int y = (contrastImage.rows / 6 * 5); y < contrastImage.rows; y++) {
			for (int x = (contrastImage.cols / 5 * 2); x > 0; x--) {
				if (magic2.at<uchar>(y, x) == 255) {
					if (x > xmar) {
						xmar = x;
					}
				}

			}
		}
		for (int y = (contrastImage.rows / 6 * 5); y < contrastImage.rows; y++) {
			for (int x = (contrastImage.cols / 5 * 2); x < contrastImage.cols; x++) {
				if (magic2.at<uchar>(y, x) == 255) {
					if (x - xmar < marindex) {
						marindex = x - xmar;
						xmax = x;
					}
					if (marindex == 0) {
						marindex = x - xmar;
						xmax = x;
					}
				}
			}
		}
		if (marindex > (xmar + 30)) {
			marindex = marindex - 30;
		}
		if (xmar == 0 || marindex == 0) {
			xmar = (contrastImage.cols / 5 * 2) - 75;
			marindex = 150;
		}
		cv::Mat blank(closing.size(), CV_8U, cv::Scalar(0xFF));
		cv::Mat dest;
		//워터세그먼트 모델
		// Create markers image
		Mat markers(closing.size(), CV_8U, cv::Scalar(-1));
		//Rect(topleftcornerX, topleftcornerY, width, height);
		//top rectangle
		markers(Rect(0, 0, closing.cols, 5)) = Scalar::all(1);
		//bottom rectangle
		markers(Rect(0, closing.rows - 5, closing.cols, 5)) = Scalar::all(1);
		//left rectangle
		markers(Rect(0, 0, 5, closing.rows)) = Scalar::all(1);
		//right rectangle
		markers(Rect(closing.cols - 5, 0, 5, closing.rows)) = Scalar::all(1);
		//centre rectangle
		int centreW = closing.cols / 2;
		int centreH = closing.rows / 4;
		markers(Rect(xmar, closing.rows / 6 * 5, marindex, closing.rows / 6)) = Scalar::all(2);
		markers.convertTo(markers, CV_BGR2GRAY);
		imshow("markers", markers);
		//Create watershed segmentation object
		WatershedSegmenter segmenter;
		segmenter.setMarkers(markers);
		cv::Mat wshedMask = segmenter.process(closing);
		cv::Mat mask;
		Mat eroding;

		convertScaleAbs(wshedMask, mask, 1, 0);
		double thresh = threshold(mask, mask, 1, 255, THRESH_BINARY);
		erode(closing, eroding, Mat(), Point(1, 1), 1);
		bitwise_and(closing, eroding, dest, mask);
		dest.convertTo(dest, CV_8U);
		imshow("final_result", dest);
		Mat something;
		cvtColor(dest, something, CV_RGB2GRAY);
		Mat hard;
		hard = magic2.clone();
		int count = 0;
		for (int y = 0; y < contrastImage.rows; y++) {
			for (int x = 0; x < contrastImage.cols; x++) {
				if (something.at<uchar>(y, x) == 0) {
					magic2.at<uchar>(y, x) = 0;
				}
			}
		}
		int countmax = contrastImage.cols / 4 * 2 - contrastImage.rows / 5 * 2;
		int k = 0;
		for (int y = 0; y < contrastImage.rows; y++) {
			for (int x = 0; x < contrastImage.cols; x++) {
				k = abs(contrastImage.rows - y);
				if (x < (contrastImage.cols / 5) + k / 2) {
					hard.at<uchar>(y, x) = 0;
				}
				else if (x >(contrastImage.cols / 5 * 4) - k / 2) {
					hard.at<uchar>(y, x) = 0;
				}
				else if (y < contrastImage.rows / 5*3){
					hard.at<uchar>(y, x) = 0;
				}
				if (y == (contrastImage.rows / 5 * 3) - 1) {

				}
			}
		}
		//움직이는 장애물 계산
		Mat calculatemov;
		calculatemov = closing.clone();
		int tmpmov = 0;
		for (int y = 0; y < contrastImage.rows /5*4; y++) {
			for (int x = 0; x < contrastImage.cols; x++) {
				if (hard.at < uchar>(y, x) != 0) {
					count++;
					tmpmov = tmpmov + y + abs(x - contrastImage.cols / 2);
				}
				else {
					calculatemov.at<Vec3b>(y, x)[0] = 0;
					calculatemov.at<Vec3b>(y, x)[1] = 0;
					calculatemov.at<Vec3b>(y, x)[2] = 0;
				}
			}
		}
		int movcounter = 0;
		if (saveset) {
			for (int y = 0; y < contrastImage.rows; y++) {
				for (int x = 0; x < contrastImage.cols; x++) {
					if (savemov.at<uchar>(y, x) != 0) {
						calculatemov.at<Vec3b>(y, x)[0] = 0;
						calculatemov.at<Vec3b>(y, x)[1] = 0;
						calculatemov.at<Vec3b>(y, x)[2] = 0;
					}
					//else if (calculatemov.at<Vec3b>(y, x)[0] != 0 || calculatemov.at<Vec3b>(y, x)[1] != 0 || calculatemov.at<Vec3b>(y, x)[2] != 0) {
					//movcounter++;
					//}
				}
			}
			if (count != 0) {
				tmpmov = (tmpmov / count) * 5;
			}
			movcounter = tmpmov;
		}
		else if (count != 0) {
			tmpmov = (tmpmov / count) * 5;
		}
		// 장애물 계산판별 computer vision
		cvtColor(calculatemov, savemov, CV_RGB2GRAY);
		saveset = true;
		if (count > 100) {
			errorhandle++;
		}
		else if (errorhandle > 5) {
			errorhandle = 5;
		}
		else if (errorhandle>0) {
			errorhandle--;
		}
		else if(errorhandle <3){
			obf =0;
		}

		if (errorhandle > 3) {
			if (movcount != 0 && count > 100) {
				if (movcounter > tmpmov * 2) {
					if (downhandle > 5) {
						if (count < 70 && stairbit ==false && downbit == false) {
							if(obf == 0){
								recv_message[0] = 'o';
								write_server(client, recv_message);
						}
						obf ++;
							}
					}
					else if(stairbit ==false && downbit == false){
						if(obf ==0){
							recv_message[0] = 'c';
							write_server(client, recv_message);
					}	
					obf ++;
					}
				}
				else {
					if (downhandle > 5) {
						if (count < 70 && stairbit ==false && downbit == false) {
							if(obf ==0){
								recv_message[0] = 'o';
								write_server(client, recv_message);
						}
						obf++;
						}
					}
					else if(stairbit ==false && downbit == false){
						if(obf ==0){
							recv_message[0] = 'o';
							write_server(client, recv_message);
					}
					obf++;
					}
				}
			}
			else if (count > 70 && stairbit ==false && downbit == false) {
				if(obf ==0){
					recv_message[0] = 'o';
					write_server(client, recv_message);
			}
			obf++;
			}
			if(downbit && count < 140 && count >70){
				if(obf ==0){
					recv_message[0] = 'o';
					write_server(client, recv_message);
			}
			obf++;
			}
		}
		movcounter = 0;
		movcount = tmpmov;
		int cross = 0;
		bool largestbit = false;
		for (int y = 0; y < contrastImage.rows; y++) {
			for (int x = 0; x < contrastImage.cols; x++) {
				if (something.at<uchar>(y, x) != 0) {
					if (!largestbit) {
						cross = y;
						largestbit = true;
					}
				}
			}
		}
		if (cross > contrastImage.rows / 5 * 3) {
			noisehandle++;
		}
		else if (noisehandle > 4) {
			noisehandle = 4;
		}
		else if (noisehandle>0) {
			noisehandle--;
		}
		//딥러닝코드로 넘어감.
		if (test_flag == 1 ) {
			if (noisehandle > 4 || stairhandle > 6 ) {
					recv_message[0] = 'r';
					write_server(client, recv_message);
					int ret = system("python3 opencv_save.py");
					char buffer[10];
					test_flag =0;
					return 0;
			}
		}
		else if(noisehandle <2){
			test_flag = 0;
		}
		int downstair = 0;
		int countforstair = 0;
		for (int y = 1; y < contrastImage.rows; y++) {
			int x = contrastImage.cols/2;
			if (bincheck.at<uchar>(y, x) == 255 && bincheck.at<uchar>(y - 1, x) != 255) {
				if(bincheck.at<uchar>(y, x-2) == 255 && bincheck.at<uchar>(y, x+2) == 255){
						if(bincheck.at<uchar>(y, x-1) = 255 && bincheck.at<uchar>(y, x+1) == 255){
						countforstair++;
					}
				}
					}
			}
		if (countforstair > 2) {
			stairhandle++;
		}
		else if (stairhandle>8) {
			stairhandle = 8;
		}
		else if (stairhandle>0) {
			stairhandle--;
		}
		if (downindex > 120 ) {
			downhandle++;
		}
		else if (downhandle > 15) {
			downhandle = 15;
		}
		else if (downhandle>0) {
			downhandle--;
		}
		else if(downhandle<1){
			dof =0;
		}
		if(stairbit == false){
			upf =0;
		}
			
		if (stairhandle > 8  && downbit == false && downhandle>6 && noisehandle>3) {

			stairbit = true;
			stairbitcheck = 0;
		}
		else if(stairhandle > 3 && downbit == false && downhandle>6 && noisehandle>3){
			stairbitcheck =0;
		}
		else if (noisehandle > 3 && stairbit == true) {
			stairbitcheck--;
		}
		else if (stairbitcheck > 15 && downhandle <3 && noisehandle<3) {
			stairbit = false;
			stairbitcheck =0;
		}
		else {
			stairbitcheck++;
		}
		if (stairbit) {
			if (upf == 0) {
							if(test_flag ==0){
				recv_message[0] = 'u';
				write_server(client, recv_message);
			}
			}
			upf++;
		}
		else if (downhandle > 30 && stairbit == false) {
			noisehandle = 0;
			downbit = true;
			downstairbit = 1;
			if(dof ==0){
							if(test_flag ==0){
				recv_message[0] = 'd';
				write_server(client, recv_message);
			}
		}
		dof++;
		}
		else if (downbit && stairbit == false) {
		dof++;
		}
		if (downstairbit > 0) {
			downstairbit++;
		}
		if (downstairbit > 1500) {
			downstairbit = 0;
			downbit = false;
		}
		imshow("..", hard);
		//imshow("gray", something);
		//imshow("calculated", magic2);

		if (waitKey(30) >= 0)
			return 1;
		if (recv_message == NULL) {
			printf("client disconnected\n");
			break;
		}
		if(dof > 50){
			dof =0;
		}
		if(upf > 50){
			upf =0;
		}
		if(obf >50){
			obf =0;
		}
	}
	return 0;
}

int main() {
	int i = 0;
	int client = init_server();
	while (1) {
		image_process(client);
		if (waitKey(30) >= 0) {
			break;
		}
	}
	return 0;
}
